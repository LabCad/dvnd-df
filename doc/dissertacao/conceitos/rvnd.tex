\section{RVND} \label{sec:rvndClassico}

O método RVND clássico~\cite{souza2010} é apresentado no Algoritmo~\ref{alg:rvnd}, como um procedimento sequencial, este depende do passo anterior para continuar o seu processamento, de acordo com o resultado anterior o método pode decidir se move para a próxima vizinhança ou volta para a primeira.
Podemos ver no condicional da linha \ref{alg:rvndTeste} que após obter a melhor solução para a vizinhança atual, o RVND verifica se esta é melhor que a solução atual, caso seja então o método volta pra a primeira vizinhança, caso contrário segue para a seguinte.

\begin{algorithm}[htpb]
\caption{RVND clássico}
\label{alg:rvnd}
\begin{algorithmic}[1]
    \Function{RVND}{Solução: $s$}
        \Let{$N$}{$\{N^1,\dots,N^{kmax}\}$} \Comment{Vizinhanças em ordem aleatória}
        \For{$k \leftarrow 1$ to $kmax$}
            \Let{$s'$}{ $s''$ com $f(s'') \le f(s''') \mid \forall s''' \in N^k(s)$} \Comment{Melhor solução de $N^k(s)$}
            
            \If{$f(s') < f(s)$} \label{alg:rvndTeste}
                \Let{$s$}{$s'$}
                \Let{$k$}{$1$}
            \Else
                \Let{$k$}{$k + 1$}
            \EndIf
        \EndFor
        \Return{s'}
    \EndFunction
\end{algorithmic}
\end{algorithm}

A cada iteração o RVND retorna uma solução $s' = m_y^x$ com $\widehat{m_y^x}(s) < \widehat{m_i^x}(s) \mid \forall m_i^x \in M^x$, que corresponde à melhor solução para a vizinhança atual.

% \mathscr{M}
Considerando $ \mathcal{M} = M^{RVND} = M^1 \cup M^2 \cup \dots \cup M^k $ o conjunto com os movimentos de todas as vizinhanças usadas pelo RVND, então em termos de movimento temos que a solução $s''$ retornada ao final do RVND pode ser escrita como $s'' = m_z \circ s$ com $m_z \in \mathcal{M}$ e $\widehat{m_z}(s) < \widehat{m_i}(s) \mid \forall m_i \in \mathcal{M}$.
