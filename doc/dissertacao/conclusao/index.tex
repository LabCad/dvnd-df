\chapter{Conclusões} \label{cap:conclusao}

%%% ---
%%% TODO List
%%% Fazer um levantamento do background dos problemas
%%% Italo na uff que mexeu no MLP junto com Rosseti
%%% Alterar para Revisão de literatura e conceituação teórica
%%% ---

% \input{conclusao/lcrvnd.tex}

Foi possível simular uma memória global em um dataflow pelo uso do nó de \textit{flip-flop} apresentado na Seção~\ref{subsec:flipFlop} de forma a prover uma memória para o nó \textit{man} do grafo dataflow do DVND, expresso na Figura~\ref{fig:dvndGraph}.

Conforme discutido na Seção~\ref{subsec:multiplasSaidas}, foi proposta a melhoria da biblioteca \textit{Sucuri} para que os nós de seus grafos comportem múltiplas portas de saída, sendo visto na Seção~\ref{sec:resultadosMultiplasPortas} que os resultados indicam sua eficiência para instâncias com tamanho maior ou igual a 318.

\section{RVND}

Foi discutido na Seção~\ref{sec:resultadosRVND} que em termos de melhoria na qualidade da solução não foi encontrada grande diferença nos métodos RVND em sua implementação clássica e da implementação em dataflow.

Em termos de tempo de execução houve uma pequena diferença em algumas instâncias pesando para a implementação dataflow e em outras para a implementação clássica.

\section{DVND}

No que diz respeito a comparação entre o DVND implementado em dataflow e a implementação original podemos ver que a versão clássica apresentou melhores tempos para as menores instâncias, sendo alcançado pela tempo da implementação em dataflow apenas na instância 5, de tamanho 657.
Apenas na instância 7 (tamanho 1001) o DVND em dataflow conseguiu melhorar o tempo do DVND clássico, contudo a melhoria dos resultados com o aumento do tamanho da solução indica que o mesmo possui tempo de execução mais controlado para grandes instâncias.

Em termos de valor da solução encontrada pode se ver na discussão da Seção~\ref{sec:resultadosDVND} que o DVND clássico conseguiu melhorar mais a solução inicial quando comparado à implementação em dataflow.

É importante ressaltar que tanto a implementação clássica quanto a implementação em dataflow do DVND melhoraram o tempo de execução quando comparadas ao RVND dataflow ou mesmo o clássico.

\section{GDVND}

Desta forma foi possível mostrar que o GDVND consegue diminuir a necessidade de explorar vizinhanças pois, conforme discutido na Seção~\ref{sec:gdvndTimeMan}, o tempo gasto por esse na exploração de vizinhanças é menor para as maiores instâncias, contudo carece de uma melhor estratégia para combinar os movimentos pois este está tomando uma parte significativa do tempo de execução do procedimento como um todo.

% \input{conclusao/dvnd.tex}

\section{Propostas futuras}

\subsection{Testar com instâncias maiores} \label{subsec:instanciasMaiores}

No intuito de verificar melhor o desempenho do método dataflow DVND e sua escalabilidade uma prova de conceito imaginada pra ser utilizada é a realização de teste computacionais para instâncias maiores, tendo em vista a comparação de resultados com instâncias do clássico PCV.

\subsection{Decomposição de vizinhanças} \label{subsec:decomposicaoVizinhancas}

Conforme descrito na seção~\ref{subsec:metodologiaDecomposicaoVizinhancas}, as vizinhanças exploradas nos problemas não são indivisíveis, desta forma uma maneira de proporcionar maior paralelismo pode ser feita através da decomposição das destas em sub vizinhanças de forma a serem exploradas paralelamente.

Acredita-se que a decomposição de vizinhanças aliada a composição de movimentos pode proporcionar um grande ganho em termos de qualidade da solução uma convergência muito mas rápida ao serem aplicados mais de um movimento simultaneamente, melhorando assim o tempo da busca local que em geral é a etapa mais custosa em termos computacionais para o processo de solução de um problema de otimização.

% \input{conclusao/publicacoesCronograma.tex}